// Generated by ReScript, PLEASE EDIT WITH CARE

import Lodash from "lodash";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var Prisma = {};

function camelCase(s) {
  return Lodash.camelCase(s);
}

var Lodash$1 = {
  camelCase: camelCase
};

function ok_or(o, e) {
  if (o !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(o)
          };
  } else {
    return e;
  }
}

function relatedTo(field) {
  var relationRegex = /([A-Za-z]+?)To([A-Za-z]+)/g;
  return Belt_Result.flatMap(Belt_Result.flatMap(ok_or(field.relationName, {
                      TAG: /* Error */1,
                      _0: "No relation name"
                    }), (function (relationName) {
                    return ok_or(Caml_option.null_to_opt(relationRegex.exec(relationName)), {
                                TAG: /* Error */1,
                                _0: "No matches for regex: " + relationName + ""
                              });
                  })), (function (match) {
                var len = match.length;
                if (len !== 1 && len !== 0) {
                  return {
                          TAG: /* Ok */0,
                          _0: match.map(function (elem) {
                                return Belt_Option.getExn((elem == null) ? undefined : Caml_option.some(elem));
                              })
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "less matches than expected"
                        };
                }
              }));
}

function force_relation(field) {
  return Belt_Result.getExn(relatedTo(field));
}

var BadPrimitiveType = /* @__PURE__ */Caml_exceptions.create("Helpers.BadPrimitiveType");

function toPrimitiveType(field) {
  var match = field.relationName;
  var match$1 = field.type;
  switch (match$1) {
    case "Boolean" :
        return "bool";
    case "DateTime" :
        return "Js.Date.t";
    case "Float" :
        return "float";
    case "Int" :
        return "int";
    case "String" :
        return "string";
    default:
      if (match !== undefined) {
        if (match$1 === "FindMany") {
          var findManyRe = /([A-Z][a-z]+)/;
          var item = findManyRe.exec(match);
          var found;
          if (item !== null) {
            found = item;
          } else {
            throw {
                  RE_EXN_ID: BadPrimitiveType,
                  message: "Could not determine relation name: " + field.type + "",
                  Error: new Error()
                };
          }
          var item$1 = Caml_array.get(found, 0);
          var findName;
          if (item$1 == null) {
            throw {
                  RE_EXN_ID: BadPrimitiveType,
                  message: "Regex matched but returned undefined: " + field.type + "",
                  Error: new Error()
                };
          }
          findName = item$1;
          return "Externals." + findName + "." + field.type + ".t";
        }
        var item$2 = relatedTo(field);
        var matches;
        if (item$2.TAG === /* Ok */0) {
          matches = item$2._0;
        } else {
          throw {
                RE_EXN_ID: BadPrimitiveType,
                message: "Could not find relation (expected to be in the format 'FieldToOtherField'): " + field.type + ": " + item$2._0 + "",
                Error: new Error()
              };
        }
        var r = Caml_array.get(matches, 1);
        if (r === field.type) {
          return "" + r + ".CreateLinkArgs.t";
        } else {
          return "" + field.type + ".WhereUniqueInput.t";
        }
      }
      throw {
            RE_EXN_ID: BadPrimitiveType,
            message: "No relation but found unknown type: " + field.type + "",
            Error: new Error()
          };
  }
}

function toObjectKeyName(field) {
  return Lodash.camelCase(field.name);
}

function annotation(field) {
  if (Lodash.camelCase(field.name) !== field.name) {
    return "@as(\"" + field.name + "\")";
  }
  
}

function toNamedArgumentImpl(field) {
  var match = field.relationName;
  var match$1 = field.isRequired;
  var isRequired = match !== undefined ? false : match$1;
  var objectKeyValue = isRequired ? "" + Lodash.camelCase(field.name) + ": " + Lodash.camelCase(field.name) + "" : "?" + Lodash.camelCase(field.name) + "";
  var keyName = Lodash.camelCase(field.name);
  var match$2 = annotation(field);
  var objectKey = isRequired ? (
      match$2 !== undefined ? "" + match$2 + " " + keyName + "" : "" + keyName + ""
    ) : (
      match$2 !== undefined ? "" + match$2 + " " + keyName + "?" : "" + keyName + "?"
    );
  var type_ = toPrimitiveType(field);
  var match$3 = field.type;
  var match$4 = field.isList;
  var match$5 = field.relationName;
  var exit = 0;
  switch (match$3) {
    case "Boolean" :
        if (match$4 && match$5 !== undefined) {
          if (isRequired) {
            return {
                    namedArgument: "bool=?",
                    namedArgumentType: "bool=?",
                    objectType: "bool",
                    objectKey: objectKey,
                    objectKeyValue: objectKeyValue
                  };
          }
          
        } else {
          exit = 2;
        }
        break;
    case "FindMany" :
        if (!(match$5 !== undefined && !isRequired)) {
          exit = 2;
        }
        break;
    default:
      exit = 2;
  }
  if (exit === 2) {
    if (match$4) {
      if (match$5 === undefined) {
        if (isRequired) {
          return {
                  namedArgument: ": array<" + type_ + ">",
                  namedArgumentType: "array<" + type_ + ">",
                  objectType: "array<" + type_ + ">",
                  objectKey: objectKey,
                  objectKeyValue: objectKeyValue
                };
        } else {
          return {
                  namedArgument: "=?",
                  namedArgumentType: "array<" + type_ + ">=?",
                  objectType: "array<" + type_ + ">",
                  objectKey: objectKey,
                  objectKeyValue: objectKeyValue
                };
        }
      }
      if (isRequired) {
        return {
                namedArgument: ": array<" + type_ + ">",
                namedArgumentType: "array<" + type_ + ">",
                objectType: "array<" + Caml_array.get(Belt_Result.getExn(relatedTo(field)), 1) + ".WhereUniqueInput.t>",
                objectKey: objectKey,
                objectKeyValue: objectKeyValue
              };
      }
      
    } else {
      if (match$5 === undefined) {
        if (isRequired) {
          return {
                  namedArgument: ": " + type_ + "",
                  namedArgumentType: "" + type_ + "",
                  objectType: "" + type_ + "",
                  objectKey: objectKey,
                  objectKeyValue: objectKeyValue
                };
        } else {
          return {
                  namedArgument: "=?",
                  namedArgumentType: "" + type_ + "=?",
                  objectType: "" + type_ + "",
                  objectKey: objectKey,
                  objectKeyValue: objectKeyValue
                };
        }
      }
      if (isRequired) {
        return {
                namedArgument: ": " + type_ + "",
                namedArgumentType: "" + type_ + "",
                objectType: "" + Caml_array.get(Belt_Result.getExn(relatedTo(field)), 2) + ".WhereUniqueInput.t",
                objectKey: objectKey,
                objectKeyValue: objectKeyValue
              };
      }
      
    }
  }
  return {
          namedArgument: "=?",
          namedArgumentType: "" + type_ + "=?",
          objectType: "" + type_ + "",
          objectKey: objectKey,
          objectKeyValue: objectKeyValue
        };
}

function toNamedArgument(field) {
  return "~" + Lodash.camelCase(field.name) + "" + toNamedArgumentImpl(field).namedArgument + "";
}

function toNamedArgumentType(field) {
  return "~" + Lodash.camelCase(field.name) + ": " + toNamedArgumentImpl(field).namedArgumentType + "";
}

function toObjectType(field) {
  var parsed = toNamedArgumentImpl(field);
  return "" + parsed.objectKey + ": " + parsed.objectType + "";
}

function toObjectKeyValue(field) {
  return "" + toNamedArgumentImpl(field).objectKeyValue + "";
}

function toObjectName(model) {
  return Lodash.camelCase(model.name);
}

export {
  Prisma ,
  Lodash$1 as Lodash,
  ok_or ,
  relatedTo ,
  force_relation ,
  BadPrimitiveType ,
  toPrimitiveType ,
  toObjectKeyName ,
  annotation ,
  toNamedArgumentImpl ,
  toNamedArgument ,
  toNamedArgumentType ,
  toObjectType ,
  toObjectKeyValue ,
  toObjectName ,
}
/* lodash Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE

import Lodash from "lodash";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var Prisma = {};

function camelCase(s) {
  return Lodash.camelCase(s);
}

var Lodash$1 = {
  camelCase: camelCase
};

function ok_or(o, e) {
  if (o !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(o)
          };
  } else {
    return e;
  }
}

function relatedTo(field) {
  var relationRegex = /([A-Za-z]+?)To([A-Za-z]+)/g;
  return Belt_Result.flatMap(Belt_Result.flatMap(ok_or(field.relationName, {
                      TAG: /* Error */1,
                      _0: "No relation name"
                    }), (function (relationName) {
                    return ok_or(Caml_option.null_to_opt(relationRegex.exec(relationName)), {
                                TAG: /* Error */1,
                                _0: "No matches for regex: " + relationName + ""
                              });
                  })), (function (match) {
                var len = match.length;
                if (len !== 1 && len !== 0) {
                  return {
                          TAG: /* Ok */0,
                          _0: match.map(function (elem) {
                                return Belt_Option.getExn((elem == null) ? undefined : Caml_option.some(elem));
                              })
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "less matches than expected"
                        };
                }
              }));
}

var BadPrimitiveType = /* @__PURE__ */Caml_exceptions.create("Helpers.BadPrimitiveType");

function toPrimitiveType(field) {
  var match = field.relationName;
  var match$1 = field.type;
  if (match !== undefined) {
    if (match$1 === "FindMany") {
      var findManyRe = /([A-Z][a-z]+)/;
      var item = findManyRe.exec(match);
      var found;
      if (item !== null) {
        found = item;
      } else {
        throw {
              RE_EXN_ID: BadPrimitiveType,
              message: "Could not determine relation name: " + field.type + "",
              Error: new Error()
            };
      }
      var item$1 = Caml_array.get(found, 0);
      var findName;
      if (item$1 == null) {
        throw {
              RE_EXN_ID: BadPrimitiveType,
              message: "Regex matched but returned undefined: " + field.type + "",
              Error: new Error()
            };
      }
      findName = item$1;
      return "Externals." + findName + "." + field.type + ".t";
    }
    var item$2 = relatedTo(field);
    var matches;
    if (item$2.TAG === /* Ok */0) {
      matches = item$2._0;
    } else {
      throw {
            RE_EXN_ID: BadPrimitiveType,
            message: "Could not find relation (expected to be in the format 'FieldToOtherField'): " + field.type + ": " + item$2._0 + "",
            Error: new Error()
          };
    }
    var r = Caml_array.get(matches, 1);
    if (r === field.type) {
      return "" + r + ".WhereUniqueInput.t";
    } else {
      return "" + field.type + ".WhereUniqueInput.t";
    }
  }
  var match$2 = field.type;
  switch (match$2) {
    case "Boolean" :
        return "bool";
    case "Float" :
        return "float";
    case "Int" :
        return "int";
    case "DateTime" :
    case "String" :
        return "string";
    default:
      throw {
            RE_EXN_ID: BadPrimitiveType,
            message: "No relation but found unknown type: " + field.type + "",
            Error: new Error()
          };
  }
}

function toObjectKey(field) {
  return Lodash.camelCase(field.name);
}

function annotation(field) {
  if (Lodash.camelCase(field.name) !== field.name) {
    return "@as(\"" + field.name + "\")";
  }
  
}

function toObjectType(field) {
  return "" + Lodash.camelCase(field.name) + ": " + Lodash.camelCase(field.name) + "";
}

function toNamedArgument(field) {
  var type_ = toPrimitiveType(field);
  var match = field.isList;
  var match$1 = field.relationName;
  var match$2 = field.isRequired;
  if (match$2) {
    if (match) {
      if (match$1 !== undefined) {
        return "~" + Lodash.camelCase(field.name) + ": array<" + type_ + ">";
      } else {
        return "~" + Lodash.camelCase(field.name) + "=?";
      }
    } else {
      return "~" + Lodash.camelCase(field.name) + ": " + type_ + "";
    }
  } else {
    return "~" + Lodash.camelCase(field.name) + "=?";
  }
}

function toNamedArgumentType(field) {
  var type_ = toPrimitiveType(field);
  var match = field.type;
  var match$1 = field.isList;
  var match$2 = field.relationName;
  var match$3 = field.isRequired;
  var tmp;
  var exit = 0;
  if (match$1) {
    if (match$2 !== undefined) {
      exit = 1;
    } else {
      tmp = match$3 ? "array<" + type_ + ">" : "" + type_ + "=?";
    }
  } else if (match$2 !== undefined) {
    exit = 1;
  } else {
    tmp = match$3 ? "" + type_ + "" : "array<" + type_ + ">=?";
  }
  if (exit === 1) {
    tmp = match === "Boolean" ? "bool" : (
        match$3 ? "" + type_ + "=?" : "" + type_ + "=?"
      );
  }
  return "~" + Lodash.camelCase(field.name) + ": " + tmp;
}

export {
  Prisma ,
  Lodash$1 as Lodash,
  ok_or ,
  relatedTo ,
  BadPrimitiveType ,
  toPrimitiveType ,
  toObjectKey ,
  annotation ,
  toObjectType ,
  toNamedArgument ,
  toNamedArgumentType ,
}
/* lodash Not a pure module */

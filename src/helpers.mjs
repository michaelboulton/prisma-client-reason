// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Lodash from "lodash";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var Prisma = {};

var Lodash$1 = {};

function relatedTo(field) {
  return Belt_Option.mapWithDefault(Belt_Option.flatMap(field.relationName, (function (relationName) {
                    var re = /([A-Za-z]+?)To([A-Za-z]+)/g;
                    return Caml_option.null_to_opt(re.exec(relationName));
                  })), {
              TAG: /* Error */1,
              _0: "No matches"
            }, (function (match) {
                var len = match.length;
                if (len !== 1 && len !== 0) {
                  return {
                          TAG: /* Ok */0,
                          _0: match
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "less matches than expected"
                        };
                }
              }));
}

var UnknownType = /* @__PURE__ */Caml_exceptions.create("Helpers.UnknownType");

function toPrimitiveType(field) {
  var match = field.relationName;
  var match$1 = field.type;
  if (match !== undefined) {
    if (match$1 === "FindMany") {
      var findManyRe = /([A-Z][a-z]+)/;
      var matches = Belt_Option.getExn(Caml_option.null_to_opt(findManyRe.exec(match)));
      var findName = Belt_Option.getExn(Caml_option.nullable_to_opt(Caml_array.get(matches, 0)));
      return "Externals." + findName + "." + field.type + ".t";
    }
    var r = Belt_Option.getExn(Caml_option.nullable_to_opt(Caml_array.get(Belt_Result.getExn(relatedTo(field)), 1)));
    if (r === field.type) {
      return "" + r + ".WhereUniqueInput.t";
    } else {
      return "" + field.type + ".WhereUniqueInput.t";
    }
  }
  var match$2 = field.type;
  switch (match$2) {
    case "Boolean" :
        return "bool";
    case "Float" :
        return "float";
    case "Int" :
        return "int";
    case "DateTime" :
    case "String" :
        return "string";
    default:
      throw {
            RE_EXN_ID: UnknownType,
            message: field.type,
            Error: new Error()
          };
  }
}

function toObjectKey(field) {
  return Lodash.camelCase(field.name);
}

function annotation(field) {
  if (Lodash.camelCase(field.name) !== field.name) {
    return "@as(\"" + field.name + "\")";
  }
  
}

export {
  Prisma ,
  Lodash$1 as Lodash,
  relatedTo ,
  UnknownType ,
  toPrimitiveType ,
  toObjectKey ,
  annotation ,
}
/* lodash Not a pure module */
